<?php
include (ABSOLUTE_PATH."/model/response.php");// подключается модель ответа

class request{

    private $request; // поле класса
    private $response;// поле класса(будет использоваться для создании объекта модели ответа (response))

    public function __construct($request){ //конструктор класса. вызывается при создании объекта и присваивает переменной request запрос (используется в ind.php)
        $this->request = $request;
    }

    private  function get_element($file, $xpath){// Этот метод принимает путь до файла и xpath по которому ищет элемент на странице
        $html = new DOMDocument(); // создается объект класса DOMDocument
        @$html->loadHTMLFile($file); // вытаскивается html из файла и загружается в переменную
        $path = new DOMXPath($html); // создается объект класса DOMXPath (передается html в конструктор)
        $nodes = $path->query($xpath);//ищится элемент по xpath в html и передается в переменную
        return $nodes; // возвращается найденый элемент
    }


    private function savePage($url){// метод используется для скачивание страницы с результатом запроса
        if(file_exists(ABSOLUTE_PATH."/page/yandexpage.html")) { //проверяется. существует ли файл с html кодом
            unlink(ABSOLUTE_PATH."/page/yandexpage.html"); // если файл существует, то он удаляется
        }
        $page = file_get_contents($url); // открывает страницу по url и выгружает содержимое в переменную.
        $fp = fopen(ABSOLUTE_PATH."/page/yandexpage.html", "w"); // создает файл yandexpage.html в каталоге page
        fwrite($fp, $page); // записывает содержимое переменной в файл (содержимое бралось с реального url) по сути кланирование страницы с выдачей
        fclose($fp);//закрывает файл
    }

    private function getHTML(){// метод используется для конструирования поискового get запроса
        $insert = str_replace(" ", "%20", $this->request);// т.к. в яндекс пробелы нужно передавать символом %20 , то мы бирем искомую фразу, ищем в ней пробелы и заменяем их на этот символ
        $url =  "https://xmlsearch.yandex.ru/search/?text=".$insert."&lr=2";//конструируем простой гет запрос в яндекс (такой, как передается в браузерную строку)
        $this->savePage($url);// передаем эту строку вметод, который потом скачает эту страницу и передаст в файл
    }


    private function splitTo($text){//если посмотреть как отображаются сайты в выдачи, то можно увидить по мимо адрес ещё и текст после › . в этом методе просто откидывается все лишнее после символа ›
        $url = explode('›',$text);// из текста, который содержит адрес мы просто откидываем все лишнее и оставляем нужный адрес
        return $url; // здесь просто возвращаем этот адрес
    }

    private function getArray(){// в этом методе идет логика, которая конструирует список сайтов
        $this->getHTML(); // вызываем метод getHTML. Он подготавливает страницу из которой будут доставаться адреса сайтов
        $arr=array();// создаем массив для списка адресов
        for($i=0;$i>-1;$i++){// т.к. нужна логика отсеивания ненужных адресов, то создается бесконечный цикл т.к. заранее неизвестно какого размера будет список с полезными адресами
            $this->response = new response(//создается объект из модели ответа (класс response) и передается в конструктор адрес сайта
                $this->splitTo(// вызывается метод, который из текста, который содержит тест и адрес и достает только текст
                $this->get_element(ABSOLUTE_PATH."/page/yandexpage.html", "//*[@class=\"path organic__path\"]")->item($i)->textContent)[0]);//вызывается метод который принимает путь до файла и xpath и ищет элемент
            //тут логика такая: достаем текст, который содержит элемент, удаляем все лишнее и оставляем только адрес, создаем объект с типом response и отдаем ему в конструктор адрес сайта
            switch ($this->response->getUrl()){// это фильтр, который убирает ненужные сайты. Он смотрит адрес в объекте и решает помещать его в массив или нет
                case "Яндекс.Картинки":break;// если такой адрес, то происходит выход из фильтра и берется следующая строка
                case "Яндекс.Видео":break;// если такой адрес, то происходит выход из фильтра и берется следующая строка
                default : // если запрещенных адресов, которые прописаны в фильтре нет, то адрес записывается в массив
                    $arr[$i]="<br>".$this->response->getUrl()."</br>"; // запись адреса в массив <br> для переноса в html
                    break;// выход из фильтра
            }
            if(count($arr)==5){// проверяет длину массива с адресами
                break; // если длина равна 5 (как было по тз) то выходим из цикла
            }
        }
        return $arr;//возвращаем массив с адресами
    }

    public function getResponse(){//отдаем список адресов (этот метот и вызывается у объекта, который был создан в ind.php)
        $s="";// переменная для записи списка адресов
        for($i=0;$i<count($this->getArray());$i++){//цикл для перебора всех адресов (равен длине массива с адресами)
            $s=$s.$this->getArray()[$i];//запись адресов
        }
        return $s;// возврат строки с адресами
    }

}
